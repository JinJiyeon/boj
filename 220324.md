## 유형 > DFS

- visited 체크를 안 하면 무한 루프에 빠질 수 있다!



#### 여행경로

- dfs 로 지나온 footprint 를 구하는 문제였다.
- ret 을 체크하지 않으면 가능한 모든 경우를 구한다. 하지만 우리는 알파벳 순으로 가장 빠른 경우만 구하면 된다.
- ret 을 체크해 구현해보자

  - 재귀함수는 스택에 쌓인다. 한번 도달하더라도 스택을 빠져나오는 게 어렵다
  - 한번 도달하면 flag 를 세워준다. 매번 flag 를 체크하고, flag 가 세워졌으면 종료(return)한다


- 비슷한 문제로 백준 > 양구출작전 이 있다.

```python
from collections import defaultdict

def solution(tickets):
    global leng, answer, finished
    
    adj = defaultdict(list)
    for stt, dst in tickets:
        adj[stt].append([dst, 0])
        adj[stt].sort()
    
    finished = 0
    leng = len(tickets)
    answer = []
    dfs('ICN', ['ICN'], adj, 0)
    return answer[0]

def dfs(stt, routes, adj, j):
    global leng, answer, finished
    
    if j == leng:
        answer.append(routes)
        finished = 1
        return 
      
    n = len(adj[stt])
    for i in range(n):
        nxt = adj[stt][i]
        if nxt[1] == 0:
            nxt[1] = 1
            ret = dfs(nxt[0], routes + [nxt[0]], adj, j+1)
            nxt[1] = 0
            if finished:
                return 
```



