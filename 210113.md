## 해시 > 베스트앨범

- [출처](https://programmers.co.kr/learn/courses/30/lessons/42579)

- Lv 3 이상 = 네이버 코테 수준 인 것 같다.

- 자잘자잘한 실수로 한시간 이상 날려먹었다. 일단 문제의 조건 (3. 고유번호가 낮은 노래) 을 하나 빼먹어서 테케에서 걸렸고. 그리고 인덱스 실수로 런타임 에러가 발생했었다.

- sort lambda 에 대해서 잘 기억해두자.

  ```python
  lst.sort(key = lambda x : (x[0], -x[1]), reverse = True)
  ```

- 다음 문장은 의외로 IndexError 가 발생하지 않는다.

  ```python
  lst = [0]
  for l in lst[:2]:
  	print(l)
  ```

  

## 스택큐 > 주식가격

- [출처](https://programmers.co.kr/learn/courses/30/lessons/42584)

- 이중 for문에서 break 하면 outer for 까지 나와버린다. inner for를 함수로 작성해보았다. 하지만 효율성은 좋지 않았고..

  ```python
  def getIndexOfLowerInt(tmp, target):
      for t in range(len(target)):
          if tmp > target[t]:
              return t+1
      return len(target)
  
  def solution(prices):
      answer = []
      lgt = len(prices)
      
      for p in range(lgt):
          ans = getIndexOfLowerInt(prices[p], prices[p+1:])  
          answer.append(ans)
      return answer
  ```

- 같은 로직에 deque 만 써도 효율성이 좋아진다.

  ```python
  from collections import deque
  
  def solution(prices):
      answer = []
      prices = deque(prices)
      
      while prices:
          sec = 0
          p = prices.popleft()
          
          for price in prices:
              sec += 1
              if price < p:
                  break
          answer.append(sec)
      
      return answer
  ```

- 아직 이해하지 못한 해결책 [출처](https://gurumee92.tistory.com/170)

  ```python
  def solution(prices):
      n = len(prices)
      # 1. answer를 prices 길이와 맞춘다.
      answer = [0] * n
      # 2. 스택 생성
      st = []
      # 3. 0 ~ n-1 초까지 순회
      for i in range(n):
          # 1. 스택 비지 않고, prices[top] > prices[i] 이라면 다음 반복
          # 1-1. 스택에서 마지막에 저장된 시간 top 꺼냄
          # 1-2. answer[top]에 i - top을 저장
          while st and prices[st[-1]] > prices[i]:
              top = st.pop()
              answer[top] = i - top
          # 2. 스택에 현재 시간 i 저장
          st.append(i)
  
      # 4. 만약 스택이 남아있다면, 스택이 빌 때까지 다음 반복
      while st:
          # 1. 스택에서 마지막에 저장된 시간 top 꺼냄
          # 2. answer[top]에 가장 마지막 시간 n - i 에서 top을 뺸 시간 저장
          top = st.pop()
          answer[top] = n - 1 - top
  
      return answer
  ```

  