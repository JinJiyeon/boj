## 정렬 > 가장 큰 수

- 조합으로 풀 경우 O(N!) 의 시간이 걸린다. 1 < N < 100,000 이고 1초 이내에 풀어야 하므로 적합하지 않다.

- 문자열의 정렬과 숫자의 정렬은 다르다

  ```python
  # 문자열
  ['34343', '333', '30303']
  # 숫자
  ['34343', '30303', '333']
  ```

- map

  ```python
  listResult = list(map(function, listOriginal))
  # listOriginal 의 원소에 접근해서 function 을 적용하여, 새로운 list 를 만듦
  
  def func_pow(x): 
    return pow(x, 5) 
  result2 = list(map(func_pow, [1, 2, 3, 4, 5]))
  
  result2 = list(map(lambda x: x ** 5, [1, 2, 3, 4, 5]))
  ```

  

## 유형 > 이분탐색

- 전제 조건은 리스트가 정렬되어 있어야 한다.
- while (left <= right)

- mid 값보다 구하고자 하는 값이 높으면 left를 mid+1로 만들어주고 낮으면 right를 mid-1로 만들어 줍니다. 
- 중간점의 데이터 8이 더 크므로 중간점 이후의 값은 확인할 필요가 없다. `right = mid -1`
- 중간점의 데이터 2가 더 작으므로 중간점 이전의 값은 확인할 필요가 없다. `left = mid + 1`

```python
def binarySearch(array, target, start, end):
	while start <= end:
    mid = (start + end)//2
    if array[mid] == target:
      return mid
    elif array[mid] > target:
      end = mid -1
    else:
      start = mid + 1
  return None 
```

