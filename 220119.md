## 정렬 > 가장 큰 수

- 조합으로 풀 경우 O(N!) 의 시간이 걸린다. 1 < N < 100,000 이고 1초 이내에 풀어야 하므로 적합하지 않다.

- 문자열의 정렬과 숫자의 정렬은 다르다

  ```python
  # 문자열
  ['34343', '333', '30303']
  # 숫자
  ['34343', '30303', '333']
  ```

- map

  ```python
  listResult = list(map(function, listOriginal))
  # listOriginal 의 원소에 접근해서 function 을 적용하여, 새로운 list 를 만듦
  
  def func_pow(x): 
    return pow(x, 5) 
  result2 = list(map(func_pow, [1, 2, 3, 4, 5]))
  
  result2 = list(map(lambda x: x ** 5, [1, 2, 3, 4, 5]))
  ```

  

## 유형 > 이분탐색

- 전제 조건은 리스트가 정렬되어 있어야 한다.
- while (left <= right)

- mid 값보다 구하고자 하는 값이 높으면 left를 mid+1로 만들어주고 낮으면 right를 mid-1로 만들어 줍니다. 
- 중간점의 데이터 8이 더 크므로 중간점 이후의 값은 확인할 필요가 없다. `right = mid -1`
- 중간점의 데이터 2가 더 작으므로 중간점 이전의 값은 확인할 필요가 없다. `left = mid + 1`

```python
def binarySearch(array, target, start, end):
	while start <= end:
    mid = (start + end)//2
    if array[mid] == target:
      return mid
    elif array[mid] > target:
      end = mid -1
    else:
      start = mid + 1
  return None 
```



## 이분탐색 > 입국심사

- 이분탐색이 target 을 찾는 거라면, 이건 target의 최솟값을 찾는 문제였다.
- 마지막 부분을 `answer == temp` 이해하지 못 했다.

```python
def solution(n, times):
    left=0
    right=max(times)*n
    temp=right
    answer=right
    while(right>=left):
        mid=(right+left)//2
        people=0
        for i in times:
            people+=mid//i
        # 같으면
        if people==n:
            if answer>=mid:
                answer=mid
            right=mid-1
        # 크면
        elif people>n:
            right=mid-1
        # 작으면
        else:
            left=mid+1
    if answer==temp:
        return right+1
    else:
        return answer
```

- 다음과 같이 하면 깔끔해진다. (left, right) 중에 가장 작은 것(left)를 return 한다

```python
def solution(n, times):
    left = 1 
    right = max(times)*n 
    while(left<=right):
        mid = (left+right)//2
        total = sum([mid//t for t in times])
        if total < n :
            left = mid + 1
        else :
            right = mid -1
    return left
```





## 이분탐색 > 징검다리

- 정렬 > H-index 와 이분탐색 > 징검다리의 공통점은
  여타 문제는 귀납적으로 접근한다면 👉  `탐색을 하다보니 답이 t였다`
  두 문제는 연역적으로 접근한다 👉 `답이 t라면 조건을 만족할 것이다`

```python
# 답이 l-i 이다 ↔️ citations에 l-i 이상 값이 l-i 개다
def solution(citations):
    citations = sorted(citations)
    print(citations)
    l = len(citations)
    for i in range(l):
        if citations[i] >= l-i:
            return l-i
    return 0
```



```python
# 답이 k이다 ↔️ 간격이 k 보다 작으면 바위를 치운다. 치운 바위의 수가 2개다.
```



## 유형 > DP

- 메모리 공간을 조금 더 사용하되, 연산속도를 비약적으로 줄이는 방법이다. 예를 들어, 피보나치 수열에서 재귀함수로 풀면 f(3)을 여러번 계산해야 하지만, 그 결과를 DP 테이블에 저장해두면 처음 계산 후에 조회하면 된다.
- 완전 탐색으로 접근했을 때 시간이 매우 오래 걸리면 DP를 의심해보자. 재귀함수로 구할 수 있으면 DP로 구현해본다.
- 재귀함수 - top down 방식과 반복문 - bottom up 방식 두 가지가 있다. 일반적으로 반복문 - bottom up 방식이 더 빠르다. 함수를 호출하는 오버헤드가 적고, 호출 개수에 제한이 있을 수 있기 때문이다.

```python
# 재귀함수 - top down
d = [0]*100
def fibo(x):
  if x==1 or x==2:
    return 1
  if d[x]!=0:
    return d[x]
  d[x]=fibo(x-1)+fibo(x-2)

# 반복문 - bottom up
d = [0]*100
d[1]=1
d[2]=1
n = 99
for i in range(3, n+1):
  d[i]=d[i-1]+d[i-2]
```



## DP > N으로 표현

- 탐색을 조기종료 하는 조건을 만드는 것에서 애를 먹었다.
- `dct.get(nxt)`로 확인할 수도 있지만 `nxt in dct`로도 확인 가능하다.

