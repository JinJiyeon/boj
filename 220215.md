#### 카카오 2018

- 옛날이라 기존에 풀던 문제와 유형이 다르다. 
- 시간을 다루는 문제가 많았다. datetime을 쓸 것 없이, `hours*60 + mins` 를 활용해도 충분히 풀 수 있다.



## 데브매칭 2021

#### 행렬 테두리 회전하기

- 나는 효율성 테스트에서 나가리 되었는데, tmpArr을 만드냐 마냐에 따라 갈린다.
- tmpArr을 만들 경우 코드는 간단하지만, 그 큰 배열을 복사해야하니 시간이 많이 걸린다.
- tmpArr을 만들지 않을 경우 문제는, [r1,c1]에 있던 값이 소실된다는 것이다. 
  이를 해결하는 과정이 추가적인 사고과정을 요구한다.
  - 오염되지 않은 값을 복사해야 한다. 
  - 시작점 값은 오염될 수밖에 없는데, 이걸 tmp에 저장해뒀다가 덮어쓴다.



#### 다단계 칫솔 판매

- 나는 dfs 를 응용해서 풀었는데 잘못된 답이 나왔다. 예시를 읽어보면 이유를 알 수 있다.
  올라가는 건 총합이 아니라, 각 판매량이다. 이 차이가 rate//10에서 발생한다.

- 좀더 단순한 풀이가 있는데, dfs가 부모에서 자식을 찾는 거라면,
  while 문으로 자식에서 부모를 찾으면서 하나씩 더해주는 것이다.

  ```python
  def solution(enroll, referral, seller, amount):
      graph,ans = {},{e:0 for e in enroll}
  
      for e,r in zip(enroll,referral): graph[e]=r
  
      for s,a in zip(seller,amount):
          money = a*100
          rate = money//10
          ans[s] += money-rate
          x = graph[s]
  
          while x != "-":
              if rate==0: break
              ans[x] += rate-rate//10
              rate//=10
              x = graph[x]
  
      return list(ans.values())
  ```

  

#### 순위 검색

- 완전탐색이 아닌 이분탐색으로 구현하는 게 포인트였다. 
- 놀랍게도 이분탐색을 구현한 라이브러리가 있다.
- bisect_left(list, elem)
  list에 elem을 삽입할 위치를 찾는다. elem 이상의 값이 처음 나오는 위치를 반환한다.

