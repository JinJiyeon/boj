## DP > 백준 > 병사 배치하기

- 처음에는 dfs로 풀고, dp를 활용하지 않았다. 시간복잡도는 2^n으로, RecursionError 가 발생했다. DP와 dfs를 잘 구분하고, dfs를 사용할 때 memoization을 활용하는 게 필요하다.

- DP를 활용하면 n^2, 이분탐색을 활용하면 nlong의 시간복잡도를 가진다.

  ```python
  # 문제와 달리 증가하는 순으로 뽑는 예이다.
  
  # DP : arr[i]보다 arr[j]가 작으면 dp를 업데이트한다.
  x = 7
  arr = [4,2,5,8,4,11,15]
  dp = [1 for i in range(x)]
  for i in range(x):
      for j in range(i):
          if arr[j] < arr[i]:
              dp[i] = max(dp[i], dp[j]+1)
  print(max(dp))
  
  # 이분탐색 : 🤔
  dp = [arr[0]]
  for i in range(x):
      if arr[i] > dp[-1]: # 최댓값보다 크면 스무스하게 넣는다.
          dp.append(arr[i])
      else: 							# 최댓값보다 작으면 최댓값을 다시 계산한다. 
          idx = bisect.bisect_left(dp, arr[i]) 
          dp[idx] = arr[i]
      print(dp)
  print(len(dp))
  # 최댓값보다 작으면 최댓값을 다시 계산한다. 
  # 최댓값이 정말로 업데이트될 수도 있고, 업데이트되지 않을 수도 있다.
  # 최댓값이 업데이트되지 않더라도, dp의 길이는 변하지 않는다. 단 len(dp) == len(LIS) 지만 dp != LIS 이다.
  ```





## Trie > 프로그래머스 > 가사 검색

- 하나씩 비교하면 O(n^n) 이지만, trie를 만들면 O(N)이다.

- trie를 만들 때 재귀로 깊어지는 것에 주의해야 한다.

  `dct = {'i':{'j':[]}}, print('j' in dct), False`

  초기에 cur = trie 라고 한 것도, 반복문에서 cur = cur[w]로 깊어지기 때문이다.
  
- 활용사례 ) 검색어 자동완성, 사전에서 찾기, 문자열 검사

- [Trie 개념](https://twpower.github.io/187-trie-concept-and-basic-problem) / [코드](https://dev-note-97.tistory.com/171)