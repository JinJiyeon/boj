## 유형 > 서로소 집합

- union-find 자료구조라 불리는데, 싸피에서 했던 rep-find 유형이다.

- rep 리스트는 각 노드의 부모를 담고 있다. 유의할 점은 부모를 담고 있는 것이지 루트가 아니라는 것이다.

- 경로압축법으로 find 함수를 최적화할 수 있다. 루트에 도달할 때까지 find를 수행하는 것이 아니라, 부모 테이블값을 갱신하는 것이다. 이때 return x가 아니라 return parent[x] 임에 유의하자.

- 루트가 같은 노드를 연결하면 사이클이 발생한다.

  ```python
  parent = [i for i in range(v+1)]
  
  # after
  def findRoot(parent, x):
    if parent[x] != x:
      parent[x] = findRoot(parent, parent[x])
     return parent[x]
  	
  # before
  def findRoot(parent, x):
    if parent[x] != x:
      return findRoot(parent, parent[x])
    return x
  ```



## 유형 > 크루스칼 알고리즘

- 신장트리란, 모든 노드를 연결하되 사이클이 없는 부분 그래프이다.
- 크루스칼 알고리즘은 최소신장트리를  찾기 위한 알고리즘이다.
- 간선의 weight를 비용에 따라 오름차순으로 정렬하고. 간선을 하나씩 확인하면서 사이클이 없으면 최소 신장 트리에 포함시킨다.
- visited는 체크하지 않는다. (1234) (567) 두 개의 그래프로 분할될 수 있다.
- MST의 간선의 개수는 N-1이다. 이걸로 조기종료 할 수 있다.



## 유형 > 위상정렬

- 모든 노드를, 방향성을 거스르지 않고, 순서대로 나열하는 것이다.
- 진입차수(indegree)는 한 노드로 들어오는 간선의 개수를 말한다.
- 진입차수가 0이면 queue에 추가한다. queue에 추가된 순서가 답이다.
- 답은 여러개가 될 수 있다.





## 백준 > MST > 도시 분할 계획

- findRoot 를 두 가지 방식으로 구현할 수 있다. 경로압축법과 경로압축X법
- unionRoot 를 두 가지 방식으로 구현할 수 있다. 선빵 (`parent[findRoot(left)] = findRoot(right) `) 와 순서( `parent[findRoot(bigger)] = findRoot(smaller)`)로.
- 경로압축법 - 선빵으로 구현하면 에러가 났는데, 이는` return x` 가 아닌 `return parent[x] `로 고치면 된다.