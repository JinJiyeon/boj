##  오전

전반적으로 쉽게 풀 수 있는 방법이 있는데 그걸 캐치하지 못해서 시간이 오래 걸렸다.

#### 피로도

- 모든 경우의 수를 탐색하는 것이었다.

- dfs로 풀 경우 visited 를 초기화해주면 된다.

  ```python
  visited[j] = 1
  dfs(k - dungeons[j][1], cnt + 1, dungeons)
  visited[j] = 0
  ```

- 문제를 너무 어렵게 생각해서 접근을 잘못했다. dp를 써야한다고 생각했는데 선형으로 이루어진 게 아니므로 쓸 수 없는 문제였다.

#### 아이템 줍기

- 간단한 공식이 있는데 떠올리지 못해서 구현에 시간이 많이 걸렸다.
- 문자열은 string(1)(2) = 's'와 같이 대체가 안된다.



## 오후

#### 모음 사전

- 규칙을 찾는 게 어렵다고 느꼈는데, 문자열 sorting 규칙이었다.

- itertools

  - product(iter, repeat=2) : 중복 순열
  - combinations_with_replacement(iter, 2) : 중복 조합

- 규칙을 잘못 짚어서 5진수를 찾아보기도 했는데 아니었다.

  ```python
  int('0b101010',2)
  bin(42)
  
  int('0o52',8)
  oct(42)
  ```



#### 퍼즐 조각 채우기

- ㅗ 를 [(0,0), (1,-1), (1,0), (1,1)] 로 변환했다. dfs에서 경로를 구하는 방법을 활용했다.
- 회전을 하려면 정사각형이어야 한다. 블록을 회전시키려면 길이를 구해야하는 데 반면, 테이블은 정사각형이라 회전하기 쉽다.



