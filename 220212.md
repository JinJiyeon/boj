#### 프로그래머스 > 단어 퍼즐 [[Lv 4]](https://programmers.co.kr/learn/courses/30/lessons/12983)

- 효율성 테스트를 통과 못한 나의 풀이와, 통과한 풀이를 비교해보자
- dp를 활용해서 로직을 단축했는가?
  dp에 값을 저장하기는 했으나, 로직을 단축시키지 못했다.
  dp에서 자주 나오는 점화식 중에 하나가 `dp[i] = min(dp[i], dp[i - k] + 1)` 형태이다.
- 글자의 탐색이 효율적인가?
  strs 와 target 을 비교하는 전략을 취했는데, 이는 시간복잡도가 크다.
  대신에 target 의 일부가 set(strs) 에 있는지 검색하면, 시간복잡도가 O(1)이다.

```python
import sys
sys.setrecursionlimit(10 ** 6)

def dfs(ti, cnt, t, strs):
    global ans, dp
    if ti >= len(t): ans = min(ans, cnt); return
    if ans <= cnt: return
    for i in range(len(strs)):
        str = strs[i]
        if str == t[ti:ti + len(str)]:  # 글자를 비교
            nxtIdx = ti + len(str)
            if dp[nxtIdx] > cnt+1:
                dp[nxtIdx] = cnt+1  # dp로 로직을 단축하지는 못했다. 단순 저장용
                dfs(nxtIdx, dp[nxtIdx], t, strs)

def solution(strs, t):
    global ans, dp
    ans = len(t) + 1
    strs.sort(reverse=True)
    dp = [len(t)+1]*(len(t)+1)
    dfs(0, 0, t, strs)
    if ans == len(t) + 1: return -1
    return ans

############################################################
def solution(strs, t):
    n = len(t)
    dp = [float('inf')] * (n + 1)
    strs = set(strs)  # set을 사용하면 탐색할 때 시간복잡도 O(1)
		dp[0] = 0
    for i in range(1, n + 1): 
        for k in range(1, 6):     # 글자 길이 
            if i - k < 0: s = 0
            else: s = i - k
            if t[s:i] in strs:    # 해시값으로 글자를 검색
                dp[i] = min(dp[i], dp[i - k] + 1)
    if dp[-1] == float('inf'):
        answer = -1
    else:
        answer = dp[-1]

    return answer
```



#### 프로그래머스 > 사칙연산 [[Lv 4]](https://programmers.co.kr/learn/courses/30/lessons/1843)

- 2차원 DP를 사용했다. DP(i)(j)는 [i, j] 의 최댓값이 담겨있다. 

  ```python
  for m in range(i, j):
  	DP[i][j] = max(DP[i][j], DP[i][m] + DP[m+1][j])
  ```

- 플로이드워셜과 달리, DP는 inf 로 채워져있고, 대각선에만 값이 있다. 그래서 간격(cnt)를 조금씩 늘려나간다.

  ```python
  leng = len(arr)//2 + 1
  for cnt in range(1, leng): 		# 처음엔 01,12,23 다음엔 02,13 그다음엔 03
  	for i in range(0, leng-cnt):
  		j = i + cnt
  		for m in range(i, j):
  			DP[i][j] = max(DP[i][j], DP[i][m] + DP[m+1][j])
  ```

- +-의 결합법칙 때문에 DPmax 와 DPmin 두 가지를 생성해야 했다.  



#### 프로그래머스 > 모두 0으로 만들기 [[Lv 3]](https://programmers.co.kr/learn/courses/30/lessons/76503)

- DFS + 재귀로 푸는 문제였다.
- 모든 노드를 돌면서 + leaf 에 있는 값을 parent 로 옮겨줘야했다. 그래서 재귀함수가 쓰였다.

```python
import sys
sys.setrecursionlimit(300000)

def dfs(i, arr, adj):
    global visited, answer
    
    now = arr[i]
    visited[i] = 1
    for j in adj[i]:
        if visited[j] == 0:
            now += dfs(j, arr, adj)
    
    answer += abs(now)
    return now
```



#### 프로그래머스 > 110 옮기기 [[Lv 3]](https://programmers.co.kr/learn/courses/30/lessons/77886)

- list 에서 가장 자주 발생하는 에러 out of Index.. arr[i]로 하면 발생하지만 arr[i:i+1]로 하면 발생하지 않는다.
- `list('string') = ['s','t','r','i','n','g']`

- `''.join( list ) = 'string'`



#### 프로그래머스 > 퍼즐조각 채우기 [[Lv 3]](https://programmers.co.kr/learn/courses/30/lessons/84021)

- DFS + 재귀로 푸는 문제였다. 위의 <모두 0으로 만들기>와 유사하다.

```python
def gather(board, t, r,c, stX, stY):
    dirs = [[-1,0], [0,1], [1,0], [0,-1]]
    n = len(board)
    ret = [[stX, stY]]
    for i in range(4):
        new_r = r + dirs[i][0]
        new_c = c + dirs[i][1]
        if 0 <= new_r < n and 0 <= new_c < n:
            if board[new_r][new_c] == t:
                board[new_r][new_c] = 2
                ret += gather(board, t, new_r,new_c, stX+dirs[i][0], stY+dirs[i][1])
    return ret
```

- if tmpBlock in blocks : 해당 블록을 board와 table에서 치운다.
  이를 구현하기 위해 deepcopy 를 활용했다.
  임시 테이블과 원조 테이블을 따로 두고. 
  조건을 만족하는 경우에만 원조 테이블을 변형하도록 했다.

```python
    for i in range(4):
        table = rotate(table)
        tmpTable = deepcopy(table)
        for r in range(len(tmpTable)):
            for c in range(len(tmpTable)):
                if tmpTable[r][c] == 1:
                    tmpTable[r][c] = 2
                    tmpBlock = gather(tmpTable, 0, r,c, 0,0)
                    if tmpBlock in blocks:
                        table = deepcopy(tmpTable) # table에서 치운다
                        blocks.pop(blocks.index(tmpBlock)) # board에서 치운다
                        ans += len(tmpBlock)
                    else:
                        tmpTable = deepcopy(table) # for r,c in range(n,n) 에서 순차 탐색하므로 2를 0으로 다시 바꿔도 괜찮다.           
    return ans
```

