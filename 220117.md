## 탐욕법 > 큰 수 만들기

- 접근 아이디어는 괜찮은데, 테케가 하나씩 틀리는 경우가 많다. 그걸 잡아내는 데에도 굉장히 오랜 시간이 걸린다.

- 내가 푼 것은 9/12로, 런타임에러 2 + 시간초과 1 이 났다.
  런타임에러는 mxIdx = len(number)-1 , st = len(number) 인 경우 IndexError가 발생한다.
  또한 outCnt를 다 소진하지 못할 수도 있다.

  ```python
  # 내가 푼 것
  def solution(number, outCnt):
      st = 0
      answer = []
      while outCnt:
          mx = 0
          mxIdx = -float('inf')
          for i in range(st, min(st + outCnt + 1, len(number))):
              if mx < int(number[i]):
                  mx = int(number[i])
                  mxIdx = i
          outCnt -= (mxIdx - st)
          st = mxIdx+1
          answer.append(number[mxIdx])
      answer.extend(number[mxIdx + 1:])
      return ''.join(answer)
  
  
  # 남이 푼 것
  def solution(number, k):
      answer = [] # Stack
      
      for num in number:
          if not answer:
              answer.append(num)
              continue
          if k > 0:
              while answer[-1] < num:
                  answer.pop()
                  k -= 1
                  if not answer or k <= 0:
                      break
          answer.append(num)
          
      answer = answer[:-k] if k > 0 else answer
      return ''.join(answer)
  ```

  

## 탐욕법 > 구명보트

- 시간 제한이 있었는데

  - sort(reverse=False)로 해서 pop(0)을 줄인다
  - deque를 써서 popleft()로 바꾼다
  - pointer a, b를 사용한다

  로 해결했다



## 탐욕법 > 섬 연결하기

- 크루스칼 알고리즘

- visited = [] 로 할 경우, 01 23 연결되지만 12는 떨어진 그림이 나올 수 있다.

- 그래서 findRep(k) 가 필요하다.

  ```python
  def findRep(k, rep):
      while k != rep[k]:
          k = rep[k]
      return k
  ```

  

## 탐욕법 > 단속카메라

- 접근조차 못했던 문제