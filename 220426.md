## bisect

- 오름세 [(골드 2)](https://www.acmicpc.net/problem/3745) 는 dp와 이분탐색이 섞인 문제다.	
  - 처음에는 dp로 풀었는데 시간 초과가 났다 O(n^2) 
  - 이분탐색으로 LIS를 구한다 O(nlogn)



- bisect는 이분탐색으로 n이 array에 들어갈 위치를 알려준다

```python
from bisect import bisect_left, bisect_right

nums = [0,1,2,3,4,5,6,7,8,9]
n = 5
bisect_left(nums, n)   #5
bisect_right(nums, n)   #6
```



```python
from bisect import bisect_left

while True:
    try:
        n = int(input())
        arr = list(map(int, input().split()))
        dp = [1]
        lis = [arr[0]]
        for i in range(n):
            idx = bisect_left(lis, arr[i])
            
            # 마지막에 추가된다 = lis가 늘어난다
            if idx == len(lis):
                dp.append(dp[-1]+1)
                lis.append(arr[i])
            # 마지막에 추가되지 않는다 = 얘나 걔나 lis 길이는 같은데, 얘는 뒤에 있고 심지어 더 작다 = 대체한다
            else:
                lis[idx] = arr[i]
        print(dp[-1])
    except:
        break
```



