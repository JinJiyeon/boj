## DP

- 문제를 읽고 유형을 파악할 때
  - 여기에 규칙이 있나..? 👉 완전탐색
  - 범위가 너무 큰데..? 👉 DP
- 메모이제이션은 어떻게 할 것인가
  - 문제에서 구하는 바가 'n을 만드는 연산 횟수의 최소값' 이면 i 를 만드는 연산 횟수의 최솟값을 저장한다.
- 메모이제이션을 어디에 할 것인가
  - (X) 딕셔너리 👉 순환 도중에 딕셔너리 값이 바뀌면 error 반환함
  - (O) 리스트 : [1로 만들기](https://www.acmicpc.net/problem/1463), 
  - (O) 이중 리스트 : [동전 1](https://www.acmicpc.net/problem/2293), 



#### 1로 만들기

`dp[n] = 1 에서 n 이 되기 위한 연산 횟수`



#### 동전 1

- j원 만드는 경우의 수
- i원 이하의 동전만 사용해서 j원 만들기. 단 메모리 초과가 뜬다.
  `dp[i][j] += dp[i-1][j] + dp[i][j-coin] `
- 축약도 가능하다
  `dp[j] += dp[j-coin]`



#### 동전 2

- j원 만드는 데 필요한 동전의 최소 개수

  `dp[i] = min(dp[i], dp[i-coin]+1)`		

- 그 외에 예외처리할 사항들이 많았다.

  중복된 동전이 있다든지, target 보다 큰 동전이 있다든지 ... 
  이런 것들을 고려해서 로직을 짜야 한다.



#### 이친수

- n 자리 이친수의 개수

  `zero[n] = zero[n-1] + one[n-1],   one[n] = zero[n-1]`



#### 이동하기

- 해당 위치에 도달했을 때 먹은 사탕의 최댓값

- 구현하는 데에 여러 가지 방법이 있다. BFS 로 구현할 때에 주의해야 한다.

  - 반복문으로 구현

    ```python
    for i in range(1, N+1):
        for j in range(1, M+1):
            dp[i][j] = max(dp[i-1][j], dp[i][j-1], dp[i-1][j-1]) + candy[i-1][j-1]
    ```

- BFS 로 구현할 때에 96% 에서 에러가 난다.

  ```python
  dirs = [[1,0], [0,1], [1,1]]
  q = deque([[0, 0]])
  while q:
      r, c = q.popleft()
      for i in range(3):
          new_r = r + dirs[i][0]
          new_c = c + dirs[i][1]
  
          if not (0 <= new_r < n and 0 <= new_c < m):
            continue
          if dp[new_r][new_c] < dp[r][c] + arr[new_r][new_c]:
              dp[new_r][new_c] = dp[r][c] + arr[new_r][new_c]
              q.append([new_r, new_c])
          elif check[new_r][new_c] == 0:
              dp[new_r][new_c] = max(dp[new_r][new_c], dp[r][c] + arr[new_r][new_c])
              check[new_r][new_c] = 1
              q.append([new_r, new_c])
  print(dp[-1][-1])
  ```

  -  `if check[new_r][new_c] == 0:` 절이 없을 경우. 
    반례는 2 2 / 0 0 / 0 3 이다. 업데이트 되지 않아서 q에 남아있질 않다.
    사탕이 0초과라고 하더라도, 비슷한 예를 찾을 수 있다.
    bfs 로 이동할 때   <b>마지막 지점까지 이동할 수 있는지</b>   검증해봐야 한다.

  - 그렇다고 `dp[new_r][new_c] <= dp[r][c] + arr[new_r][new_c]` 일 때 업데이트하면 시간초과가 발생한다.
  - 그래서 업데이트가 되지 않더라도 한번은 방문하는 것이 필요하다.



#### 평범한 배낭

- 무게가 k 일 때 가치의 최댓값

- 구글링 풀이에서는 2차원으로 dp를 만들었는데 1차원 dp로도 풀 수 있다.

  - 일차원으로 풀 때 `dp[w] = max(dp[w], dp[w-weight]+value)` 인 경우

  - `dp[w-weight]` 가 업데이트되면서, 하나의 물건이 여러 개 들어가는 오류가 생긴다.

    예시 ) `3 5 // 4 2 // 3 4 // 1 5 `

  - 이를 풀기 위해서는 `dp[w-weight]` 가 업데이트되지 않도록 해야 하는데,

  - (1) 이차원으로 풀거나 (2) w 순회를 reverse 로 하거나 두가지 방법이 있다. 

    ```python
    n, k = map(int, input().split())
    arr = [list(map(int, input().split())) for _ in range(n)]
    dp = [0]*(k+1)
    for i in range(n):
        weight, value = arr[i]
        for w in range(k, weight-1, -1):
            dp[w] = max(dp[w], dp[w-weight]+value)
    print(dp[-1])
    ```



#### LCS

- `dp[r][l] = right[:r] 과 left[:l] 사이의 LCS`

- LCS 는 다음과 같이 계산된다.

  - else 부분에서 연속적으로 업데이트해야 한다는 점을 간과했다.

  ```python
  if right[r-1] == left[l-1]:
  	dp[r][l] = dp[r-1][l-1]+1
  else:
  	dp[r][l] = max(dp[r-1][l], dp[r][l-1]) 
  ```



#### 가장 긴 증가하는 부분 수열 (LIS)

- LIS 를 계산하려면 <b>최댓값</b>과 <b>길이</b>에 대한 정보가 필요하다.

- `dp[n] = 최댓값이 n인 LIS의 길이`

- dp[n] = n 번째 까지 수에서 LIS 의 길이 로 할 경우, 최댓값을 모르기 때문에 업데이트할 수 없다.

- 그래서 마지막으로 출력할 때에도 max(dp) 를 출력한다

  ```python
  n = int(input())
  arr = list(map(int, input().split()))
  dp = [1]*n
  for i in range(n):
      for j in range(i):
          if arr[i] > arr[j]:
              dp[i] = max(dp[i], dp[j]+1)
  print(max(dp))
  ```

  

#### 욕심쟁이 판다

- dp\[r]\[c] = (r, c) 에서 시작했을 때 이동할 수 있는 길이

- 재귀함수 dfs + dp 로, `dp[r][c]`에 `return dp[r][c]` 한 값을 대입한다.



- 처음에 문제 접근을 잘못했다.

  - 옮긴 지역에 전 지역보다 대나무가 더 많아야 한다... 라는 조건을 아래와 같이 풀었다.

    ```python
    if arr[new_r][new_c] < arr[r][c]:
      if check[new_r][new_c] < check[r][c] + 1:
        check[new_r][new_c] = check[r][c] + 1
        q.append([new_r, new_c])
    ```

  - 이렇게 풀면 비효율이 발생할 수 있다.
    판다의 이동 경로가 [1,3,5,9,10] 일 때 

    - 10 > 9> 5 > 3 > 1 로 접근하면 O(N)이다.

    - 1 > 3 > 5 > 9 > 10 으로 접근할 경우 O(N^2)이다.

      

- 다음은 올바른 풀이다.

  - dfs 를 재귀로 구현하고 `dp[r][c]`에 `return dp[r][c]` 한 값을 대입해서 해결할 수 있다.
  - `return dp[r][c]+1` 이다. 
    dp\[original_r]\[original_c] 에 대입하거나, ans 와 비교할 때 +1 한 값을 사용한다.
  - 초기값이 -1 이고, dp에는 이동할 수 있는 칸의 개수를 넣는다. 최종값은 dp+1 일 것이다. 

  ```python
  n = int(input())
  arr = [list(map(int, input().split())) for _ in range(n)]
  dp = [[-1]*n for _ in range(n)]
  dirs = [[-1,0], [0,1], [1,0], [0,-1]]
  
  def dfs(r, c):
      if dp[r][c] == -1:
          dp[r][c] = 0
  
          for i in range(4):
              new_r = r + dirs[i][0]
              new_c = c + dirs[i][1]
  
              if 0 <= new_r < n and 0 <= new_c < n:
                  if arr[r][c] < arr[new_r][new_c]:
                      dp[r][c] = max(dp[r][c], dfs(new_r, new_c))
                      
      return dp[r][c]+1	
  
  ans = 0
  for r in range(n):
      for c in range(n):
          ans = max(ans, dfs(r,c))
  print(ans)
  ```



#### 로봇 조종하기

- 이미 탐사한 지역은 다시 탐사하지 않는다 를 구현하기가 어려웠다.
  - 이미 탐사한 지역을 다시 들리는 경우는 좌우 좌우 도리도리 할 때이다.
  - 좌로 이동하는 것, 우로 이동하는 것을 나눠서 최적값을 구한다.
- dfs 에서 visited 구하는 방법과 헷갈렸는데, 이건 왜 안 되는지 좀더 파봐야 한다.

