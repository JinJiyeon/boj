## DP > 정수삼각형

- 재귀함수 - top down 방식과 반복문 - bottom up 방식 두 가지가 있다. 일반적으로 반복문 - bottom up 방식이 더 빠르다. 



## DP > 등굣길

- 문제를 제대로 읽자. 최단경로의 '길이'가 아니라 '개수'를 구하는 문제다.
- 이동 방향이 오른쪽, 아래 밖에 없다. bfs 로 안 풀고 for 문으로만 풀어도 된다. 그리고 그게 더 빠르다.
- 문제에 따라 row, col을 뒤집은 경우가 있다.



## DP > 도둑질

- DP 유형의 특징
  - 최솟값, 최댓값을 찾는다.
  - 점화식이 있는 경우가 많다.
  - 점화식은 n=1, 2, 3, 4 로 나누어서 생각해본다.



## 유형 > 다익스트라

- 방문하지 않은 노드 중에서 최단 거리가 가장 짧은 노드를 선택한다. 최단 거리가 짧은 노드를 선택할 때 리스트를 순회하는 것보다 heapq를 활용하면 효율적이다.

- 탐색 노드에 연결되어 있어서 방문을 하는 경우가 있고, 최단 거리로 뽑혀서 탐색이 완료되는 경우가 있다. 후자의 경우 전자보다 항상 경로가 짧다. 왜냐하면 전자는 101+alpha 고 후자는 100이니까.

- heapq의 사용법

  ```python
  import heapq
  
  # 기존 리스트를 힙으로 변환 
  lst = [4,1,7,3,8,5]
  heapq.heapify(lst)
  
  # 힙에 원소 추가
  heap = []
  heapq.heappush(heap, 4)
  
  # 가장 작은 원소 뽑기
  nxt = heapq.heappop(heap)
  nxt2 = heap[0]	#단, heap[1]은 두번째로 작은 원소가 아니다
  
  # 힙에 튜플을 추가하면 맨 앞에 있는 값을 기준으로 최소 힙이 구성된다
  maxHeap = []
  for l in lst:
    heapq.heappush(maxHeap, (-l, l))
  ```

  

## 힙 > 디스크 컨트롤러

- 이유는 모르겠지만 pointer를 이동할 때 `+= 1` 로 하는 것이 안전하다. `+=jobs[0][0]` 으로 하면 뻑갈 때가 많다.



## 힙 > 이중우선순위큐

- 리스트를 힙으로 만들 경우

  - heap[1]은 두번째로 작은 값이 아니다

  - heap.remove(value) 메소드는 살아있다!

    이걸로 동기화를 해준다.