## 유형 > DFS

#### 피로도

- 방문체크를 하기 위해 visited[i] = 1 에서 0 으로 초기화해주는 유형



#### 퍼즐 조각 채우기

- 탐색한 공간을 메모해두는 유형

- 특정한 target

  - `visited = [0]*n` / `visited = [[0]*n for _ in range(n)`
  - target 에 도착하면 visited 를 검사한다

- 특정한 target X

  - 재귀함수의 인자에 index 를 넘겨주고, visited 에 추가한다.

  ```python
  def dfs(graph, x, y, position, n, num):
      dic = {0:[-1, 0], 1:[0, 1], 2:[1, 0], 3:[0, -1]}
      
      ret = [position]
      
      for i in range(4):
          nx = x + dic[i][0]
          ny = y + dic[i][1]
          
          if 0 <= nx < n and 0 <= ny < n and graph[nx][ny] == num:
              graph[nx][ny] = 2
              ret = ret + dfs(graph, nx, ny, [position[0]+dic[i][0], position[1]+dic[i][1]], n, num)
      
      return ret
  ```



- 아래 풀이는 세가지 포인트가 있다.

  - 상대적인 모양을 저장했다.

  - 회전을 하려면 정사각형이어야 한다.

  - board에 table을 채워넣으면 해당 칸은 지워줘야 한다. 이를 deepcopy를 활용해 처리했다.

    ```python
    for i in range(4):
        tables = rotate(tables)	# 기준점
        testTables = deepcopy(tables)
        for r,c in range(4,4):
        	if testTables[r][c] == 1:
          	result = dfs(testTables, r, c, [0, 0], leng, 1) # testTable 에서 일단 지움
            if result in blocks: # 지워야 함. 덮어씀
              tables = deepcopy(testTables)
            else: # 지우면 안 됨. 원상복구
            	testTables = deepcopy(tables)
    ```

    



## 구현 > 아이템 줍기

- 칸이 아닌 교점을 기준으로 생각한다.
- 좌표를 두배 늘려서 생각한다.





## 상호평가

- r,c를 바꿔서 생각하는 문제였다.
- transpose 후 풀었다.