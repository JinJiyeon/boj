## 스택큐 > 프린터

- enumerate를 활용했다.

- deque 는 popleft/append 의 속도가 빠르지만 slicing 을 지원하지 않아서 사용하지 않았다.

  ```python
  from collections import deque
  def solution(priorities, location):
      en = list(enumerate(priorities))
      cnt = 0
      while en:
          e, p = en[0]
          for t in en[1:]:
              if t[1] > p:
                  en.append(en.pop(0))
                  break
          else:
              tmp = en.pop(0)
              cnt += 1
              if tmp[0] == location:
                  return cnt
  ```

  

- deque 의 rotate 라는 메소드가 있다.

  데크를 num만큼 회전한다(양수면 오른쪽, 음수면 왼쪽)

  ```python
  deq = deque([1, 2, 3, 4, 5])
  
  deq.rotate(1)
  print(deq)
  # deque([5, 1, 2, 3, 4])
  ```



## 스택큐 > 다리를 지나느 트럭

- 두 개의 값을 고려해야 해서 (a,b) 형태로 담았다

- bridge(0)(1) 을 해야 하는데, bridge(0)(0)을 해서 오류가 났다. 

  print로 디버깅을 했고, 디버깅에만 1시간 정도 쏟았다. 잠시 침대에 누웠다가 다시 보니까 틀린 부분이 보였다. 

- 다른 사람 풀이인데, `else q.append(0)`을 하는 방식이 신박했다.

```python
def solution(bridge_length, weight, truck_weights):
    q=[0]*bridge_length
    sec=0
    while q:
        sec+=1
        q.pop(0)
        if truck_weights:
            if sum(q)+truck_weights[0]<=weight:
                q.append(truck_weights.pop(0))
            else:
                q.append(0)
    return sec
```

