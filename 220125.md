## 그리디 > 프로그래머스 > 무지의 먹방 라이브

- pointer로 풀었는데 시간 초과가 났다. 이렇게 풀 때마다 정확성도 틀리는데 왜일까..
  습관적으로 종료조건을 앞에 두었는데. 여기서 문제가 발생했다. 
  food_times[pointer] > 0 인 값을 찾은 후에 종료해야 했다.
  종료조건을 맨 마지막에 두니 해결되었다.

- 유튜브 영상을 보고 구현해보았다.
- `while lst : if (lst.pop) elif (lst.pop)` 로 해야 하는데 
  `while lst : if (lst.pop) if (lst.pop) `로 잘못 구현해서 런타임 에러가 발생했다. len(lst) == 1인 경우 lst.pop이 두번 발생해서 에러가 나는 것이다.
- lst.pop(0)으로 했더니 시간 초과가 났다. for문이나 heapq로 구현하면 괜찮다.
  pop()은 O(1)이지만 pop(0)은 O(N)이다.
  for 문에서는 pop 대신에 slicing 을,
  heapq 는 heappop, heappush를 사용하였다.

```python
import heapq 
def solution(food_times, k): 
    answer = -1 
    h = [] 
    for i in range(len(food_times)): 
        heapq.heappush(h, (food_times[i], i + 1)) 
    food_num = len(food_times) # 남은 음식 개수 
    previous = 0 # 이전에 제거한 음식의 food_time 
    while h: 
        # 먹는데 걸리는 시간: (남은 양) * (남은 음식 개수) 
        t = (h[0][0] - previous) * food_num 
        # 시간이 남을 경우 현재 음식 빼기 
        if k >= t: 
            k -= t 
            previous, _ = heapq.heappop(h) 
            food_num -= 1 
        # 시간이 부족할 경우(음식을 다 못먹을 경우) 남은 음식 중에 먹어야 할 음식 찾기 
        else: 
            idx = k % food_num 
            h.sort(key=lambda x: x[1]) 
            answer = h[idx][1] 
            break 
    return answer


```



## 구현 > 프로그래머스 > 자물쇠와 열쇠

- 3 <= M<=N <= 20 으로 작다. 따라서 완전탐색을 써도 된다. for문이 많이 쓰인다고 겁먹지 말자.
- for문이 중첩되면 헷갈릴 수 있다. 그런 부분은 함수로 만들자
- 90도 회전하는 것을 어떻게 구현할 것인가?